/**
 * MnSi constants
 * @author Tobias Weber <tweber@ill.fr>
 * @date jul-18
 * @license GPLv2 (see 'LICENSE' file)
 */

#ifndef __MNSI_CONSTS_H__
#define __MNSI_CONSTS_H__

#include "tlibs2/libs/math17.h"
#include "tlibs2/libs/units.h"


/**
 * constants
 * The values are from the theoretical models by. M. Garst and J. Waizner:
 *	- https://doi.org/10.1088/1361-6463/aa7573
 *	- https://kups.ub.uni-koeln.de/7937/
 *	- Personal communications with M. Garst, 2017-2020.
 * Further values, e.g. g_hoc and g_chi, are from the paper and its Python code:
 *	- https://doi.org/10.1103/PhysRevLett.115.097203
 */
template<class t_real = double> constexpr t_real g_pi = tl2::pi<t_real>;
template<class t_real = double> constexpr t_real g_kB
	= static_cast<t_real>(tl2::kB<t_real>/tl2::meV<t_real>*tl2::kelvin<t_real>);
template<class t_real = double> constexpr t_real g_muB
	= static_cast<t_real>(tl2::muB<t_real>/tl2::meV<t_real>*tl2::tesla<t_real>);
template<class t_real = double> constexpr t_real g_chi = 0.34;
template<class t_real = double> constexpr t_real g_hoc = -0.0073;
template<class t_real = double, bool use_hoc=1> constexpr t_real g_hoc_b = use_hoc ? g_hoc<t_real> : 0.;
template<class t_real = double> constexpr t_real g_a = 4.558;
template<class t_real = double> constexpr t_real g_g = -tl2::g_e<t_real>;
template<class t_real = double> constexpr t_real g_kh_A_29K = 0.039;
template<class t_real = double> constexpr t_real g_kh_rlu_29K = g_kh_A_29K<t_real> / (t_real(2.)*g_pi<t_real> / g_a<t_real>);


/**
 * helix pitch in inverse angstroms
 */
template<class t_real = double>
constexpr t_real g_kh_A(t_real T)
{
	constexpr t_real T1 = 20.;
	constexpr t_real T2 = 29.;

	constexpr t_real A1 = 0.036;			// at 20 K
	constexpr t_real A2 = g_kh_A_29K<t_real>;	// at 29 K

	constexpr t_real m = (A2-A1) / (T2-T1);
	constexpr t_real t = A2 - m*T2;

	return m*T + t;
}


/**
 * helix pitch in rlu
 */
template<class t_real = double>
constexpr t_real g_kh_rlu(t_real T)
{
	return g_kh_A<t_real>(T) / (t_real(2.)*g_pi<t_real> / g_a<t_real>);
}


/**
 * get upper critical field
 *	- Theoretical values calculated with "heli.dat_Bc2.gpl" script generated by heliphase.cpp
 *	- Experimental values were measured and provided by A. Bauer (http://doi.org/10.1103/PhysRevB.85.214418).
 */
template<class t_real = double>
t_real get_bc2(t_real T, bool use_theo_units=1, bool use_dipole=1)
{
	if(use_theo_units)
	{
		if(T >= 0.)
			return 0.;

		// calculated with "heliphase"
		//const t_real amp1 = 1.58786033; // scaling
		//const t_real ex1 = 0.49965808;  // critical exponent
		//return amp1 * std::pow(-T, ex1);

		t_real amp2 = 1.;
		if(use_dipole)
			amp2 = 1.11966394;
		return g_g<t_real> * amp2 * std::sqrt(-0.5 - 0.5*T);
	}
	else
	{
		const t_real p1[] = { 0.473163, 0.0257403, 16.8606, 0.274611, 4.67147e-05 };
		const t_real p2[] = { 0.50892, 0.139686, 28.3493, 0.23784, 0.00781078 };
		const t_real p3[] = { 0.453534, 0.153873, 30.679, 4.70025, 1.36435 };

		const t_real *p = p1;
		if(T <= 11.3)
			p = p1;
		else if(T > 11.3 && T < 27.)
			p = p2;
		else if(T >= 27.)
			p = p3;

		const t_real Tc = p[2];
		const t_real tau = (Tc-T) / Tc;
		if(T >= Tc)
			return 0.;

		return p[0]*std::pow(tau, p[1]) *
			(1. + p[3]*std::pow(tau, p[4]));
	}
}


/**
 * get field magnitude in theoretical units from experimental one
 */
template<class t_real = double>
t_real get_B_exp_from_theo(t_real T_theo, t_real T_exp, t_real B_exp, bool use_dipole=1)
{
	t_real bc2_theo = get_bc2(T_theo, true, use_dipole);
	t_real bc2_exp = get_bc2(T_exp, false, use_dipole);

	return B_exp / bc2_exp * bc2_theo;
}


#endif
